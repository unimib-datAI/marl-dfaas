# This Python script is expected to be imported by all Jupyter notebooks.
from pathlib import Path
import logging
import sys
import os
import warnings

import IPython.core.debugger as debugger

import numpy as np

import cloudpickle

import matplotlib

# Add the parent directory (the root directory of the project) to sys.path. This
# is needed to load modules like dfaas_utils or dfaas_env.
sys.path.append(Path(os.getcwd()).parent.as_posix())

import dfaas_env
import dfaas_upperbound
import dfaas_utils

# Reset the matplotlib logger to warning, because Ray (called by dfaas_env
# module) changes the level to debug.
_matplotlib_logger = logging.root.manager.loggerDict["matplotlib"]
_matplotlib_logger.setLevel("WARNING")

# Initialize logger for this module.
logging.basicConfig(
    format="%(asctime)s %(levelname)s %(filename)s:%(lineno)d -- %(message)s",
    level=logging.DEBUG,
)
logger = logging.getLogger(Path(__file__).name)

# Convert NumPy warning to errors.
np.seterr(all="raise")

# This module-level variable holds the environment object. Supports multiple
# experiments (the key is the experiment path, value is the object).
_env = dict()

# Same as _env but for experiment configs (SACConfig, PPOConfig...).
_exp_config = dict()


def _env_init(exp_dir):
    """Initializes the internal _env variable by creating the environment with
    the configuration extracted from the given experiment directory."""
    if not exp_dir.exists():
        logger.critical(f"Experiment directory not found: {exp_dir.as_posix()!r}")
        raise FileNotFoundError(exp_dir)

    # Experiment configuration (read the existing one).
    exp_config = dfaas_utils.json_to_dict(exp_dir / "exp_config.json")

    # Environment configuration (read the existing one).
    env_config = dfaas_utils.json_to_dict(exp_dir / "env_config.json")

    # Create the environment with the given env config.
    global _env
    match exp_config["env"]:
        case "DFaaS":
            _env[exp_dir] = dfaas_env.DFaaS(config=env_config)
        case "SingleDFaaS":
            _env[exp_dir] = dfaas_upperbound.SingleDFaaS(config=env_config)
        case _:
            logger.critical(f"Unsupported environment for exp: {exp_dir.as_posix()!r}")
            raise ValueError(exp_dir)


def get_env(exp_dir):
    """Returns the environment from the given experiment directory."""
    if exp_dir not in _env:
        _env_init(exp_dir)

    return _env[exp_dir]


def _exp_config_init(exp_dir):
    """Initializes the internal _exp_config variable by creating the experiment
    config from the given experiment directory ("params.pkl" file)."""
    if not exp_dir.exists():
        logger.critical(f"Experiment directory not found: {exp_dir.as_posix()!r}")
        raise FileNotFoundError(exp_dir)

    # Deserialize the params.pkl file. This file is generated by RLlib when
    # running an experiment.
    params_file = exp_dir / "params.pkl"
    with params_file.open("rb") as params:
        config = cloudpickle.load(params)

    # Save the configuration to the global-level cache.
    global _exp_config
    _exp_config[exp_dir] = config


def get_exp_config(exp_dir):
    """Returns the experiment config (PPOConfig, SACConfig...) from the given
    experiment directory."""
    if exp_dir not in _exp_config:
        _exp_config_init(exp_dir)

    return _exp_config[exp_dir]


def set_trace():
    """Open IPython debugger in interactive-mode."""
    debugger.set_trace()


# Default size (10) is too small.
font = {"size": 12}
matplotlib.rcParams["figure.figsize"] = [9, 6]
matplotlib.rc("font", **font)

# Disable Ray's warnings.
warnings.filterwarnings("ignore", category=DeprecationWarning)


def get_experiments(exp_prefix):
    """Searches for experiment directories under the given exp_prefix
    directory (preferably a Path object, but can also be a string) and
    returns a list of tuples (experiment name and experiment path)."""
    # Force to have a Path object.
    if not isinstance(exp_prefix, Path):
        exp_prefix = Path(exp_prefix)

    # Scan the files and directories under exp_prefix.
    exps = []
    for exp in exp_prefix.iterdir():
        if (exp / "exp_config.json").exists():  # A single experiment.
            exps.append((exp.name, exp))
            continue

        # The experiment is a directory with sub-experiments, add
        # each experiment individually.
        for sub_exp in exp.iterdir():
            if (sub_exp / "exp_config.json").exists():  # A single experiment.
                exps.append((f"{exp.name}/{sub_exp.name}", sub_exp))

    # Newest experiment first.
    return sorted(exps, reverse=True)
